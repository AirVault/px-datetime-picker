<link rel="import" href="css/px-datetime-picker-styles.html"/>
<link rel="import" href="../px-datetime-field/px-datetime-field.html"/>
<link rel="import" href="../px-datetime-common/px-datetime-behavior.html"/>
<link rel="import" href="../px-datetime-common/px-datetime-buttons.html"/>
<link rel="import" href="../px-datetime-common/px-datetime-button-behavior.html"/>
<link rel="import" href="../app-localize-behavior/app-localize-behavior.html" />
<link rel="import" href="../iron-dropdown/iron-dropdown.html">
<link rel="import" href="../iron-media-query/iron-media-query.html"/>
<link rel="import" href="../px-overlay/px-overlay-content.html">
<link rel="import" href="../px-overlay/px-overlay-behavior.html"/>
<link rel="import" href="px-datetime-picker-content.html">

<!--
The datetime components rely on [Moment.js](https://momentjs.com/) and [Moment Timezone](https://momentjs.com/timezone/).

#### Usage

    <px-datetime-picker></px-datetime-picker>


#### Styling
The following custom properties are available for styling. Please also refer to px-forms-design and px-buttons-design for additional style variables used by this component.

Custom property | Description
:----------------|:-------------
`--px-datetime-picker-background-color` | Background color for the panel
`--px-datetime-picker-border-color` | Border color for the panel
`--px-datetime-picker-z-index` | The z-index of the container

@element px-datetime-picker
@blurb Element allowing to pick a date using a calendar or by typing it
@homepage index.html
@demo index.html
-->
<dom-module id="px-datetime-picker">
  <template>
    <style include="px-datetime-picker-styles"></style>
    <template is="dom-if" if="[[_collapseQueryIsValid(collapseAt)]]">
      <iron-media-query query$="(max-width: {{_getCollapseQuery(collapseAt)}})" query-matches="{{_belowCollapseSize}}"></iron-media-query>
    </template>

    <px-datetime-field
      id="field"
      slot="dropdown-trigger"
      time-zone="{{timeZone}}"
      moment-obj="{{_tempMomentObj}}"
      hide-time="{{hideTime}}"
      show-time-zone="{{showTimeZone}}"
      date-format="{{dateFormat}}"
      time-format="{{timeFormat}}"
      is-selected="[[opened]]"
      required="[[required]]"
      prevent-notification-on-change
      prevent-cell-focus="[[_fillContainer]]"
      block-future-dates="{{blockFutureDates}}"
      block-past-dates="{{blockPastDates}}"
      resources="[[resources]]"
      language="[[language]]"
      formats="[[formats]]"
      date-min="[[minDate]]"
      date-max="[[maxDate]]"
      is-valid="{{fieldIsValid}}">
    </px-datetime-field>
    <px-overlay-content
      hoist="[[hoist]]"
      container-type="[[containerType]]"
      event-names='["px-datetime-button-clicked"]'>
      <px-datetime-picker-content
        id="content"
        opened="{{opened}}"
        fill-container="[[fillContainer]]"
        fit-into-element="[[fitIntoElement]]"
        block-future-dates="{{blockFutureDates}}"
        block-past-dates="{{blockPastDates}}"
        temp-moment-obj="{{_tempMomentObj}}"
        base-date="[[_tempMomentObj]]"
        time-zone="[[timeZone]]"
        day-week-start-index="[[dayWeekStartIndex]]"
        resources="[[resources]]"
        language="[[language]]"
        formats="[[formats]]"
        min-date="[[minDate]]"
        max-date="[[maxDate]]"
        hide-time="[[hideTime]]"
        time-format="{{timeFormat}}"
        show-buttons="[[showButtons]]"
        field-is-valid="[[fieldIsValid]]"
        field-elem="[[_returnField()]]">
      </px-datetime-picker-content>
    </px-overlay-content>


  </template>
</dom-module>

<script>
  Polymer({

    is: 'px-datetime-picker',
    behaviors:[
      PxDatetimeBehavior.TempMoment,
      PxDatetimeBehavior.Buttons,
      PxOverlayBehavior.sharedProperties
    ],

    /**
     * Properties block, expose attribute values to the DOM via 'notify'
     *
     * @property properties
     * @type Object
     */
    properties: {
      /**
       *
       * Can be set to show the timezone in the field. Can have 2 values:
       *  'dropdown': shows the time zone as a dropdown which the user can use to
       * select a different time zone. Only contains a subset of all time zones
       *  'extendedDropdown': shows the time zone as a dropdown which the user can use to
       * select a different time zone. Contains all existing time zones (588)
       *  'text': shows the time zone as text, non editable
       *  'abbreviatedText': shows the time zone as an abbreviated text, non editable (such as PST, EST...)
       */
      showTimeZone: {
        type: String,
        value: ''
      },
      /**
       * Whether this date picker should allow to pick time as well.
       *
       */
      hideTime: {
        type: Boolean,
        value: false
      },
      /**
       * Moment format used for the date
       *
       */
      dateFormat: {
        type: String,
        value: 'MM/DD/YYYY'
      },
      /**
       * Moment format used for the time
       *
       */
       timeFormat: {
        type: String,
        value: 'HH:mm A'
      },
      /**
       * Boolean stating if the picker is required.
       * Will result in an error if left blank.
       */
       required: {
        type: Boolean,
        value: false
      },
      /**
       * Reflects if datetime-picker container is open/visible.
       */
       opened: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * false : the datetime-picker contents will open in a panel
       * if the screen size is greater than the collapseAt value.
       * true : the datetime-picker contents will fill the window
       * or an element defined by the `fitIntoElement`. It fills
       * regardless of the collapseAt value.
       * Reflects if the field is valid.
       */
       fieldIsValid: {
        type: Boolean
      },
      /**
       * false : the dt-picker contents will open in a panel.
       * true : the dt-picker contents will fill the window
       * or an element defined by the `fitIntoElement`.
       */
       fillContainer: {
        type: Boolean,
        value: false,
        observer: '_handleFillContainer'
      },
      /**
       * used to toggle fillContainer from iron-media-query
       * without separate variable fillContainer would never be
       * true with a screen size larger then the value of collapseAt
       */
       _fillContainer: {
        type: Boolean,
        reflectToAttribute: true
      },
      /**
       * The element that the dt-picker contents will fully expand into
       * when the dt-picker is open.
       * `fillContainer` must be true in order for this property to work
       */
      fitIntoElement: {
        type: Object,
        value: window
      },
      /**
       * The width below which the datetime picker will collapse into a mobile
       * friendly menu that slides up from the bottom of the page. Use a number
       * (e.g. `450`) which will be converted to a pixel value (e.g. '450px').
       *
       * If no value is provided, the datetime picker will not collapse
       * automatically. The collapsed attribute can also be used to manually
       * collapse and un-collapse the datetime picker.
       */
       collapseAt: {
        type: Number,
        value: 100
      },
      selectedDate: {
        type: String,
        value: "Select Date"
      },
      /**
       * Output of iron-media-query
       */
      _belowCollapseSize: {
        type: Boolean,
        observer: '_handleBelowCollapseSizeChanged'
      },
      /**
       * List of key/values to be included for translating this component
       */
      resources: {
        type: Object,
        value: function() {
          return {
            'en': {
              'Today': 'Today'
            }
          };
        }
      },
      /**
      * set a default for localizing
      */
     language: {
       type: String,
       value: 'en'
     },
     /**
      * Use the key for localization if value for  language is missing. Should
      * always be true for  our components
      */
     useKeyIfMissing: {
       type: Boolean,
       value: true
     },

      /**
      * Specifies if the dropdown content should get hoisted to a container in order to escape its current stacking context
      */
      hoist: {
        type: Boolean,
        value: false
      }
    },
    listeners: {
      'px-datetime-entry-icon-clicked':'_iconClicked',
      'px-datetime-button-clicked': '_buttonClicked',
      'tap' : '_handleTap'
    },
    /**
     * Key bindings for iron-a11y-keys-behavior
     */
    keyBindings: {
      'esc' : '_onEsc',
      'enter': '_onEnter'
    },

    attached: function() {
      //we don't need to listen to the time field from the calendar
      //since it only updates the temp moment but should never trigger an
      //actual validation
      this.$.field.addEventListener('moment-obj-changed', this._tempMomentChanged.bind(this, 'field'));
      this.$.content.addEventListener('temp-moment-obj-changed', this._tempMomentChanged.bind(this, 'content'));
    },

    /*
     * Propagate focus from the host to px-datetime-field
     */
    focus: function() {
      this.$.field.focus();
    },

    /**
     */
    _onEsc: function(evt) {
      this._rollbackTempMoment();
      this.$.content._close();
    },
    /**
     */
    _onEnter: function(evt) {
      this._validateCalendarMoment();
    },
    /**
     * If the calendar is open and the dropdown is selected, close the calendar
     */
     _handleTap: function(evt) {
      if(this.opened === true){
        var path = Polymer.dom(evt).path;
        for (var i=0; i<path.length; i++) {
          if (path[i].nodeName === 'PX-DROPDOWN') {
            this.$.content._close();
            return;
          }
        }
      }
    },

    _tempMomentChanged: function(origin) {
      //this debounce is critical for Polymer 1. We are just putting this
      //call on top of the stack because of how the binding flows:
      //change in calendar => binding updates field moment => field
      //moment fires change event => binding done => calendar fires
      //change event.
      //we are therefore interested in the latest update, hence the
      //debounce. no need for an actual timing since this will all be
      //sequential.
      //In Polymer 2 in this scenario only calendar will fire a change
      //event so no problems
      this.debounce('_tempMomentChanged', function() {
        // If it is from the field, field has validated and want to update.
        // If it is from the content and we have no buttons, content has validated and we want to update
        // Else, wait for button events.
        if(origin === 'field') {
          this._applyTempMoment();
        } else if(origin === 'calendar') {
          //time changed in calendar. Only process if no button,
          if(!this.showButtons) {
            this._validateCalendarMoment();
          }
        }
      }.bind(this));
    },
    _updateSelectedDate : function(moment) {
      moment === null ? this.selectedDate = "Select Date" : this.selectedDate = moment.format('YYYY/MM/DD')
    },

    _calendarMomentChanged : function(evt) {
      this._tempMomentChanged('calendar');
      if(this.fillContainer){ this._updateSelectedDate(evt.detail.value); }
    },

    _fieldMomentChanged: function (evt) {
      if (evt.detail.value === null) { this._updateSelectedDate(evt.detail.value); }
      this._tempMomentChanged('field');
    },

    /**
     */
    _validateCalendarMoment: function() {
      if(this.opened) {
        //apply: accept if valid
        if(this.$.field.isValid) {
          this._applyTempMoment();
          this.$.content._close();
        } else {
          //don't close, can't apply if not valid
        }
      }
    },
    _closeIconClicked: function(evt) {
      this._buttonClicked(evt);
    },
    /**
     */
    _buttonClicked: function(evt) {
      if(evt.detail.action) {
       this._validateCalendarMoment();
      } else {
        this._rollbackTempMoment();
        this.$.content._close();
      }
    },
    /**
     */
    _iconClicked: function(evt) {
      if(evt.detail.dateOrTime === "Date") {
        this.$.content._open();
      }
    },

    _getVerticalOffset: function(fillContainer) {
      return !fillContainer ? 20 : 0;
    },
    _getPositionTarget: function(fillContainer, fitIntoElement) {
      return fillContainer ? fitIntoElement : this.$.field;
    },
    getElement: function(elStr) {
      return this.shadowRoot.querySelector(elStr)
    },

    _getCollapseQuery(collapseAt) {
      if (typeof collapseAt === 'number') {
        return collapseAt + 'px';
      }
      if (typeof collapseAt === 'string' && collapseAt.slice(-2) === 'px' || !isNaN(parseInt(collapseAt))) {
        return collapseAt;
      }
    },
    _collapseQueryIsValid(query) {
      if (typeof query === 'number') {
        return true;
      }
      if (typeof query === 'string' && query.slice(-2) === 'px' && !isNaN(parseInt(query))) {
        return true;
      }
      return false;
    },
    _handleBelowCollapseSizeChanged(newVal, oldVal) {
      if (newVal) {
        this._fillContainer = true;
      }
      if (!newVal && !this.fillContainer) {
        this._fillContainer = false;
      }
    },
    /**
     * Sync external fillConatiner with internal _fillConatiner
     */
    _handleFillContainer(newVal, oldVal) {
      newVal ? this._fillContainer = true : this._fillContainer = false;
    },
    _returnField: function() {
      return this.$.field;
    }
  });
</script>
